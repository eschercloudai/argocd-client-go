/*
Consolidate Services

Description of all APIs

API version: version not set
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// ApplicationServiceApiService ApplicationServiceApi service
type ApplicationServiceApiService service

type ApiApplicationServiceCreateRequest struct {
	ctx        context.Context
	ApiService *ApplicationServiceApiService
	body       *V1alpha1Application
	upsert     *bool
	validate   *bool
}

func (r ApiApplicationServiceCreateRequest) Body(body V1alpha1Application) ApiApplicationServiceCreateRequest {
	r.body = &body
	return r
}

func (r ApiApplicationServiceCreateRequest) Upsert(upsert bool) ApiApplicationServiceCreateRequest {
	r.upsert = &upsert
	return r
}

func (r ApiApplicationServiceCreateRequest) Validate(validate bool) ApiApplicationServiceCreateRequest {
	r.validate = &validate
	return r
}

func (r ApiApplicationServiceCreateRequest) Execute() (*V1alpha1Application, *http.Response, error) {
	return r.ApiService.ApplicationServiceCreateExecute(r)
}

/*
ApplicationServiceCreate Create creates an application

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApplicationServiceCreateRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceCreate(ctx context.Context) ApiApplicationServiceCreateRequest {
	return ApiApplicationServiceCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V1alpha1Application
func (a *ApplicationServiceApiService) ApplicationServiceCreateExecute(r ApiApplicationServiceCreateRequest) (*V1alpha1Application, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V1alpha1Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.upsert != nil {
		parameterAddToQuery(localVarQueryParams, "upsert", r.upsert, "")
	}
	if r.validate != nil {
		parameterAddToQuery(localVarQueryParams, "validate", r.validate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceDeleteRequest struct {
	ctx               context.Context
	ApiService        *ApplicationServiceApiService
	name              string
	cascade           *bool
	propagationPolicy *string
	appNamespace      *string
}

func (r ApiApplicationServiceDeleteRequest) Cascade(cascade bool) ApiApplicationServiceDeleteRequest {
	r.cascade = &cascade
	return r
}

func (r ApiApplicationServiceDeleteRequest) PropagationPolicy(propagationPolicy string) ApiApplicationServiceDeleteRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiApplicationServiceDeleteRequest) AppNamespace(appNamespace string) ApiApplicationServiceDeleteRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApplicationServiceDeleteExecute(r)
}

/*
ApplicationServiceDelete Delete deletes an application

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiApplicationServiceDeleteRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceDelete(ctx context.Context, name string) ApiApplicationServiceDeleteRequest {
	return ApiApplicationServiceDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ApplicationServiceApiService) ApplicationServiceDeleteExecute(r ApiApplicationServiceDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cascade != nil {
		parameterAddToQuery(localVarQueryParams, "cascade", r.cascade, "")
	}
	if r.propagationPolicy != nil {
		parameterAddToQuery(localVarQueryParams, "propagationPolicy", r.propagationPolicy, "")
	}
	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceDeleteResourceRequest struct {
	ctx          context.Context
	ApiService   *ApplicationServiceApiService
	name         string
	namespace    *string
	resourceName *string
	version      *string
	group        *string
	kind         *string
	force        *bool
	orphan       *bool
	appNamespace *string
}

func (r ApiApplicationServiceDeleteResourceRequest) Namespace(namespace string) ApiApplicationServiceDeleteResourceRequest {
	r.namespace = &namespace
	return r
}

func (r ApiApplicationServiceDeleteResourceRequest) ResourceName(resourceName string) ApiApplicationServiceDeleteResourceRequest {
	r.resourceName = &resourceName
	return r
}

func (r ApiApplicationServiceDeleteResourceRequest) Version(version string) ApiApplicationServiceDeleteResourceRequest {
	r.version = &version
	return r
}

func (r ApiApplicationServiceDeleteResourceRequest) Group(group string) ApiApplicationServiceDeleteResourceRequest {
	r.group = &group
	return r
}

func (r ApiApplicationServiceDeleteResourceRequest) Kind(kind string) ApiApplicationServiceDeleteResourceRequest {
	r.kind = &kind
	return r
}

func (r ApiApplicationServiceDeleteResourceRequest) Force(force bool) ApiApplicationServiceDeleteResourceRequest {
	r.force = &force
	return r
}

func (r ApiApplicationServiceDeleteResourceRequest) Orphan(orphan bool) ApiApplicationServiceDeleteResourceRequest {
	r.orphan = &orphan
	return r
}

func (r ApiApplicationServiceDeleteResourceRequest) AppNamespace(appNamespace string) ApiApplicationServiceDeleteResourceRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceDeleteResourceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApplicationServiceDeleteResourceExecute(r)
}

/*
ApplicationServiceDeleteResource DeleteResource deletes a single application resource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiApplicationServiceDeleteResourceRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceDeleteResource(ctx context.Context, name string) ApiApplicationServiceDeleteResourceRequest {
	return ApiApplicationServiceDeleteResourceRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ApplicationServiceApiService) ApplicationServiceDeleteResourceExecute(r ApiApplicationServiceDeleteResourceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceDeleteResource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/resource"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.namespace != nil {
		parameterAddToQuery(localVarQueryParams, "namespace", r.namespace, "")
	}
	if r.resourceName != nil {
		parameterAddToQuery(localVarQueryParams, "resourceName", r.resourceName, "")
	}
	if r.version != nil {
		parameterAddToQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.group != nil {
		parameterAddToQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.kind != nil {
		parameterAddToQuery(localVarQueryParams, "kind", r.kind, "")
	}
	if r.force != nil {
		parameterAddToQuery(localVarQueryParams, "force", r.force, "")
	}
	if r.orphan != nil {
		parameterAddToQuery(localVarQueryParams, "orphan", r.orphan, "")
	}
	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceGetRequest struct {
	ctx             context.Context
	ApiService      *ApplicationServiceApiService
	name            string
	refresh         *string
	projects        *[]string
	resourceVersion *string
	selector        *string
	repo            *string
	appNamespace    *string
}

// forces application reconciliation if set to true.
func (r ApiApplicationServiceGetRequest) Refresh(refresh string) ApiApplicationServiceGetRequest {
	r.refresh = &refresh
	return r
}

// the project names to restrict returned list applications.
func (r ApiApplicationServiceGetRequest) Projects(projects []string) ApiApplicationServiceGetRequest {
	r.projects = &projects
	return r
}

// when specified with a watch call, shows changes that occur after that particular version of a resource.
func (r ApiApplicationServiceGetRequest) ResourceVersion(resourceVersion string) ApiApplicationServiceGetRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// the selector to restrict returned list to applications only with matched labels.
func (r ApiApplicationServiceGetRequest) Selector(selector string) ApiApplicationServiceGetRequest {
	r.selector = &selector
	return r
}

// the repoURL to restrict returned list applications.
func (r ApiApplicationServiceGetRequest) Repo(repo string) ApiApplicationServiceGetRequest {
	r.repo = &repo
	return r
}

// the application&#39;s namespace.
func (r ApiApplicationServiceGetRequest) AppNamespace(appNamespace string) ApiApplicationServiceGetRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceGetRequest) Execute() (*V1alpha1Application, *http.Response, error) {
	return r.ApiService.ApplicationServiceGetExecute(r)
}

/*
ApplicationServiceGet Get returns an application by name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name the application's name
	@return ApiApplicationServiceGetRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceGet(ctx context.Context, name string) ApiApplicationServiceGetRequest {
	return ApiApplicationServiceGetRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
//
//	@return V1alpha1Application
func (a *ApplicationServiceApiService) ApplicationServiceGetExecute(r ApiApplicationServiceGetRequest) (*V1alpha1Application, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V1alpha1Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.refresh != nil {
		parameterAddToQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.projects != nil {
		t := *r.projects
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToQuery(localVarQueryParams, "projects", s.Index(i), "multi")
			}
		} else {
			parameterAddToQuery(localVarQueryParams, "projects", t, "multi")
		}
	}
	if r.resourceVersion != nil {
		parameterAddToQuery(localVarQueryParams, "resourceVersion", r.resourceVersion, "")
	}
	if r.selector != nil {
		parameterAddToQuery(localVarQueryParams, "selector", r.selector, "")
	}
	if r.repo != nil {
		parameterAddToQuery(localVarQueryParams, "repo", r.repo, "")
	}
	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceGetApplicationSyncWindowsRequest struct {
	ctx          context.Context
	ApiService   *ApplicationServiceApiService
	name         string
	appNamespace *string
}

func (r ApiApplicationServiceGetApplicationSyncWindowsRequest) AppNamespace(appNamespace string) ApiApplicationServiceGetApplicationSyncWindowsRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceGetApplicationSyncWindowsRequest) Execute() (*ApplicationApplicationSyncWindowsResponse, *http.Response, error) {
	return r.ApiService.ApplicationServiceGetApplicationSyncWindowsExecute(r)
}

/*
ApplicationServiceGetApplicationSyncWindows Get returns sync windows of the application

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiApplicationServiceGetApplicationSyncWindowsRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceGetApplicationSyncWindows(ctx context.Context, name string) ApiApplicationServiceGetApplicationSyncWindowsRequest {
	return ApiApplicationServiceGetApplicationSyncWindowsRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
//
//	@return ApplicationApplicationSyncWindowsResponse
func (a *ApplicationServiceApiService) ApplicationServiceGetApplicationSyncWindowsExecute(r ApiApplicationServiceGetApplicationSyncWindowsRequest) (*ApplicationApplicationSyncWindowsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationApplicationSyncWindowsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceGetApplicationSyncWindows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/syncwindows"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceGetManifestsRequest struct {
	ctx          context.Context
	ApiService   *ApplicationServiceApiService
	name         string
	revision     *string
	appNamespace *string
}

func (r ApiApplicationServiceGetManifestsRequest) Revision(revision string) ApiApplicationServiceGetManifestsRequest {
	r.revision = &revision
	return r
}

func (r ApiApplicationServiceGetManifestsRequest) AppNamespace(appNamespace string) ApiApplicationServiceGetManifestsRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceGetManifestsRequest) Execute() (*RepositoryManifestResponse, *http.Response, error) {
	return r.ApiService.ApplicationServiceGetManifestsExecute(r)
}

/*
ApplicationServiceGetManifests GetManifests returns application manifests

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiApplicationServiceGetManifestsRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceGetManifests(ctx context.Context, name string) ApiApplicationServiceGetManifestsRequest {
	return ApiApplicationServiceGetManifestsRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
//
//	@return RepositoryManifestResponse
func (a *ApplicationServiceApiService) ApplicationServiceGetManifestsExecute(r ApiApplicationServiceGetManifestsRequest) (*RepositoryManifestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RepositoryManifestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceGetManifests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/manifests"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.revision != nil {
		parameterAddToQuery(localVarQueryParams, "revision", r.revision, "")
	}
	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceGetManifestsWithFilesRequest struct {
	ctx        context.Context
	ApiService *ApplicationServiceApiService
	body       *ApplicationApplicationManifestQueryWithFilesWrapper
}

// (streaming inputs)
func (r ApiApplicationServiceGetManifestsWithFilesRequest) Body(body ApplicationApplicationManifestQueryWithFilesWrapper) ApiApplicationServiceGetManifestsWithFilesRequest {
	r.body = &body
	return r
}

func (r ApiApplicationServiceGetManifestsWithFilesRequest) Execute() (*RepositoryManifestResponse, *http.Response, error) {
	return r.ApiService.ApplicationServiceGetManifestsWithFilesExecute(r)
}

/*
ApplicationServiceGetManifestsWithFiles GetManifestsWithFiles returns application manifests using provided files to generate them

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApplicationServiceGetManifestsWithFilesRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceGetManifestsWithFiles(ctx context.Context) ApiApplicationServiceGetManifestsWithFilesRequest {
	return ApiApplicationServiceGetManifestsWithFilesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return RepositoryManifestResponse
func (a *ApplicationServiceApiService) ApplicationServiceGetManifestsWithFilesExecute(r ApiApplicationServiceGetManifestsWithFilesRequest) (*RepositoryManifestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RepositoryManifestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceGetManifestsWithFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/manifestsWithFiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceGetResourceRequest struct {
	ctx          context.Context
	ApiService   *ApplicationServiceApiService
	name         string
	namespace    *string
	resourceName *string
	version      *string
	group        *string
	kind         *string
	appNamespace *string
}

func (r ApiApplicationServiceGetResourceRequest) Namespace(namespace string) ApiApplicationServiceGetResourceRequest {
	r.namespace = &namespace
	return r
}

func (r ApiApplicationServiceGetResourceRequest) ResourceName(resourceName string) ApiApplicationServiceGetResourceRequest {
	r.resourceName = &resourceName
	return r
}

func (r ApiApplicationServiceGetResourceRequest) Version(version string) ApiApplicationServiceGetResourceRequest {
	r.version = &version
	return r
}

func (r ApiApplicationServiceGetResourceRequest) Group(group string) ApiApplicationServiceGetResourceRequest {
	r.group = &group
	return r
}

func (r ApiApplicationServiceGetResourceRequest) Kind(kind string) ApiApplicationServiceGetResourceRequest {
	r.kind = &kind
	return r
}

func (r ApiApplicationServiceGetResourceRequest) AppNamespace(appNamespace string) ApiApplicationServiceGetResourceRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceGetResourceRequest) Execute() (*ApplicationApplicationResourceResponse, *http.Response, error) {
	return r.ApiService.ApplicationServiceGetResourceExecute(r)
}

/*
ApplicationServiceGetResource GetResource returns single application resource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiApplicationServiceGetResourceRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceGetResource(ctx context.Context, name string) ApiApplicationServiceGetResourceRequest {
	return ApiApplicationServiceGetResourceRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
//
//	@return ApplicationApplicationResourceResponse
func (a *ApplicationServiceApiService) ApplicationServiceGetResourceExecute(r ApiApplicationServiceGetResourceRequest) (*ApplicationApplicationResourceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationApplicationResourceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceGetResource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/resource"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.namespace != nil {
		parameterAddToQuery(localVarQueryParams, "namespace", r.namespace, "")
	}
	if r.resourceName != nil {
		parameterAddToQuery(localVarQueryParams, "resourceName", r.resourceName, "")
	}
	if r.version != nil {
		parameterAddToQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.group != nil {
		parameterAddToQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.kind != nil {
		parameterAddToQuery(localVarQueryParams, "kind", r.kind, "")
	}
	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceListRequest struct {
	ctx             context.Context
	ApiService      *ApplicationServiceApiService
	name            *string
	refresh         *string
	projects        *[]string
	resourceVersion *string
	selector        *string
	repo            *string
	appNamespace    *string
}

// the application&#39;s name.
func (r ApiApplicationServiceListRequest) Name(name string) ApiApplicationServiceListRequest {
	r.name = &name
	return r
}

// forces application reconciliation if set to true.
func (r ApiApplicationServiceListRequest) Refresh(refresh string) ApiApplicationServiceListRequest {
	r.refresh = &refresh
	return r
}

// the project names to restrict returned list applications.
func (r ApiApplicationServiceListRequest) Projects(projects []string) ApiApplicationServiceListRequest {
	r.projects = &projects
	return r
}

// when specified with a watch call, shows changes that occur after that particular version of a resource.
func (r ApiApplicationServiceListRequest) ResourceVersion(resourceVersion string) ApiApplicationServiceListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// the selector to restrict returned list to applications only with matched labels.
func (r ApiApplicationServiceListRequest) Selector(selector string) ApiApplicationServiceListRequest {
	r.selector = &selector
	return r
}

// the repoURL to restrict returned list applications.
func (r ApiApplicationServiceListRequest) Repo(repo string) ApiApplicationServiceListRequest {
	r.repo = &repo
	return r
}

// the application&#39;s namespace.
func (r ApiApplicationServiceListRequest) AppNamespace(appNamespace string) ApiApplicationServiceListRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceListRequest) Execute() (*V1alpha1ApplicationList, *http.Response, error) {
	return r.ApiService.ApplicationServiceListExecute(r)
}

/*
ApplicationServiceList List returns list of applications

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApplicationServiceListRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceList(ctx context.Context) ApiApplicationServiceListRequest {
	return ApiApplicationServiceListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V1alpha1ApplicationList
func (a *ApplicationServiceApiService) ApplicationServiceListExecute(r ApiApplicationServiceListRequest) (*V1alpha1ApplicationList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V1alpha1ApplicationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.refresh != nil {
		parameterAddToQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.projects != nil {
		t := *r.projects
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToQuery(localVarQueryParams, "projects", s.Index(i), "multi")
			}
		} else {
			parameterAddToQuery(localVarQueryParams, "projects", t, "multi")
		}
	}
	if r.resourceVersion != nil {
		parameterAddToQuery(localVarQueryParams, "resourceVersion", r.resourceVersion, "")
	}
	if r.selector != nil {
		parameterAddToQuery(localVarQueryParams, "selector", r.selector, "")
	}
	if r.repo != nil {
		parameterAddToQuery(localVarQueryParams, "repo", r.repo, "")
	}
	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceListResourceActionsRequest struct {
	ctx          context.Context
	ApiService   *ApplicationServiceApiService
	name         string
	namespace    *string
	resourceName *string
	version      *string
	group        *string
	kind         *string
	appNamespace *string
}

func (r ApiApplicationServiceListResourceActionsRequest) Namespace(namespace string) ApiApplicationServiceListResourceActionsRequest {
	r.namespace = &namespace
	return r
}

func (r ApiApplicationServiceListResourceActionsRequest) ResourceName(resourceName string) ApiApplicationServiceListResourceActionsRequest {
	r.resourceName = &resourceName
	return r
}

func (r ApiApplicationServiceListResourceActionsRequest) Version(version string) ApiApplicationServiceListResourceActionsRequest {
	r.version = &version
	return r
}

func (r ApiApplicationServiceListResourceActionsRequest) Group(group string) ApiApplicationServiceListResourceActionsRequest {
	r.group = &group
	return r
}

func (r ApiApplicationServiceListResourceActionsRequest) Kind(kind string) ApiApplicationServiceListResourceActionsRequest {
	r.kind = &kind
	return r
}

func (r ApiApplicationServiceListResourceActionsRequest) AppNamespace(appNamespace string) ApiApplicationServiceListResourceActionsRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceListResourceActionsRequest) Execute() (*ApplicationResourceActionsListResponse, *http.Response, error) {
	return r.ApiService.ApplicationServiceListResourceActionsExecute(r)
}

/*
ApplicationServiceListResourceActions ListResourceActions returns list of resource actions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiApplicationServiceListResourceActionsRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceListResourceActions(ctx context.Context, name string) ApiApplicationServiceListResourceActionsRequest {
	return ApiApplicationServiceListResourceActionsRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
//
//	@return ApplicationResourceActionsListResponse
func (a *ApplicationServiceApiService) ApplicationServiceListResourceActionsExecute(r ApiApplicationServiceListResourceActionsRequest) (*ApplicationResourceActionsListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationResourceActionsListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceListResourceActions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/resource/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.namespace != nil {
		parameterAddToQuery(localVarQueryParams, "namespace", r.namespace, "")
	}
	if r.resourceName != nil {
		parameterAddToQuery(localVarQueryParams, "resourceName", r.resourceName, "")
	}
	if r.version != nil {
		parameterAddToQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.group != nil {
		parameterAddToQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.kind != nil {
		parameterAddToQuery(localVarQueryParams, "kind", r.kind, "")
	}
	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceListResourceEventsRequest struct {
	ctx               context.Context
	ApiService        *ApplicationServiceApiService
	name              string
	resourceNamespace *string
	resourceName      *string
	resourceUID       *string
	appNamespace      *string
}

func (r ApiApplicationServiceListResourceEventsRequest) ResourceNamespace(resourceNamespace string) ApiApplicationServiceListResourceEventsRequest {
	r.resourceNamespace = &resourceNamespace
	return r
}

func (r ApiApplicationServiceListResourceEventsRequest) ResourceName(resourceName string) ApiApplicationServiceListResourceEventsRequest {
	r.resourceName = &resourceName
	return r
}

func (r ApiApplicationServiceListResourceEventsRequest) ResourceUID(resourceUID string) ApiApplicationServiceListResourceEventsRequest {
	r.resourceUID = &resourceUID
	return r
}

func (r ApiApplicationServiceListResourceEventsRequest) AppNamespace(appNamespace string) ApiApplicationServiceListResourceEventsRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceListResourceEventsRequest) Execute() (*V1EventList, *http.Response, error) {
	return r.ApiService.ApplicationServiceListResourceEventsExecute(r)
}

/*
ApplicationServiceListResourceEvents ListResourceEvents returns a list of event resources

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiApplicationServiceListResourceEventsRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceListResourceEvents(ctx context.Context, name string) ApiApplicationServiceListResourceEventsRequest {
	return ApiApplicationServiceListResourceEventsRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
//
//	@return V1EventList
func (a *ApplicationServiceApiService) ApplicationServiceListResourceEventsExecute(r ApiApplicationServiceListResourceEventsRequest) (*V1EventList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V1EventList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceListResourceEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.resourceNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "resourceNamespace", r.resourceNamespace, "")
	}
	if r.resourceName != nil {
		parameterAddToQuery(localVarQueryParams, "resourceName", r.resourceName, "")
	}
	if r.resourceUID != nil {
		parameterAddToQuery(localVarQueryParams, "resourceUID", r.resourceUID, "")
	}
	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceManagedResourcesRequest struct {
	ctx             context.Context
	ApiService      *ApplicationServiceApiService
	applicationName string
	namespace       *string
	name            *string
	version         *string
	group           *string
	kind            *string
	appNamespace    *string
}

func (r ApiApplicationServiceManagedResourcesRequest) Namespace(namespace string) ApiApplicationServiceManagedResourcesRequest {
	r.namespace = &namespace
	return r
}

func (r ApiApplicationServiceManagedResourcesRequest) Name(name string) ApiApplicationServiceManagedResourcesRequest {
	r.name = &name
	return r
}

func (r ApiApplicationServiceManagedResourcesRequest) Version(version string) ApiApplicationServiceManagedResourcesRequest {
	r.version = &version
	return r
}

func (r ApiApplicationServiceManagedResourcesRequest) Group(group string) ApiApplicationServiceManagedResourcesRequest {
	r.group = &group
	return r
}

func (r ApiApplicationServiceManagedResourcesRequest) Kind(kind string) ApiApplicationServiceManagedResourcesRequest {
	r.kind = &kind
	return r
}

func (r ApiApplicationServiceManagedResourcesRequest) AppNamespace(appNamespace string) ApiApplicationServiceManagedResourcesRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceManagedResourcesRequest) Execute() (*ApplicationManagedResourcesResponse, *http.Response, error) {
	return r.ApiService.ApplicationServiceManagedResourcesExecute(r)
}

/*
ApplicationServiceManagedResources ManagedResources returns list of managed resources

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationName
	@return ApiApplicationServiceManagedResourcesRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceManagedResources(ctx context.Context, applicationName string) ApiApplicationServiceManagedResourcesRequest {
	return ApiApplicationServiceManagedResourcesRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationName: applicationName,
	}
}

// Execute executes the request
//
//	@return ApplicationManagedResourcesResponse
func (a *ApplicationServiceApiService) ApplicationServiceManagedResourcesExecute(r ApiApplicationServiceManagedResourcesRequest) (*ApplicationManagedResourcesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationManagedResourcesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceManagedResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{applicationName}/managed-resources"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationName"+"}", url.PathEscape(parameterValueToString(r.applicationName, "applicationName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.namespace != nil {
		parameterAddToQuery(localVarQueryParams, "namespace", r.namespace, "")
	}
	if r.name != nil {
		parameterAddToQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.version != nil {
		parameterAddToQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.group != nil {
		parameterAddToQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.kind != nil {
		parameterAddToQuery(localVarQueryParams, "kind", r.kind, "")
	}
	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServicePatchRequest struct {
	ctx        context.Context
	ApiService *ApplicationServiceApiService
	name       string
	body       *ApplicationApplicationPatchRequest
}

func (r ApiApplicationServicePatchRequest) Body(body ApplicationApplicationPatchRequest) ApiApplicationServicePatchRequest {
	r.body = &body
	return r
}

func (r ApiApplicationServicePatchRequest) Execute() (*V1alpha1Application, *http.Response, error) {
	return r.ApiService.ApplicationServicePatchExecute(r)
}

/*
ApplicationServicePatch Patch patch an application

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiApplicationServicePatchRequest
*/
func (a *ApplicationServiceApiService) ApplicationServicePatch(ctx context.Context, name string) ApiApplicationServicePatchRequest {
	return ApiApplicationServicePatchRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
//
//	@return V1alpha1Application
func (a *ApplicationServiceApiService) ApplicationServicePatchExecute(r ApiApplicationServicePatchRequest) (*V1alpha1Application, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V1alpha1Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServicePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServicePatchResourceRequest struct {
	ctx          context.Context
	ApiService   *ApplicationServiceApiService
	name         string
	body         *string
	namespace    *string
	resourceName *string
	version      *string
	group        *string
	kind         *string
	patchType    *string
	appNamespace *string
}

func (r ApiApplicationServicePatchResourceRequest) Body(body string) ApiApplicationServicePatchResourceRequest {
	r.body = &body
	return r
}

func (r ApiApplicationServicePatchResourceRequest) Namespace(namespace string) ApiApplicationServicePatchResourceRequest {
	r.namespace = &namespace
	return r
}

func (r ApiApplicationServicePatchResourceRequest) ResourceName(resourceName string) ApiApplicationServicePatchResourceRequest {
	r.resourceName = &resourceName
	return r
}

func (r ApiApplicationServicePatchResourceRequest) Version(version string) ApiApplicationServicePatchResourceRequest {
	r.version = &version
	return r
}

func (r ApiApplicationServicePatchResourceRequest) Group(group string) ApiApplicationServicePatchResourceRequest {
	r.group = &group
	return r
}

func (r ApiApplicationServicePatchResourceRequest) Kind(kind string) ApiApplicationServicePatchResourceRequest {
	r.kind = &kind
	return r
}

func (r ApiApplicationServicePatchResourceRequest) PatchType(patchType string) ApiApplicationServicePatchResourceRequest {
	r.patchType = &patchType
	return r
}

func (r ApiApplicationServicePatchResourceRequest) AppNamespace(appNamespace string) ApiApplicationServicePatchResourceRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServicePatchResourceRequest) Execute() (*ApplicationApplicationResourceResponse, *http.Response, error) {
	return r.ApiService.ApplicationServicePatchResourceExecute(r)
}

/*
ApplicationServicePatchResource PatchResource patch single application resource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiApplicationServicePatchResourceRequest
*/
func (a *ApplicationServiceApiService) ApplicationServicePatchResource(ctx context.Context, name string) ApiApplicationServicePatchResourceRequest {
	return ApiApplicationServicePatchResourceRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
//
//	@return ApplicationApplicationResourceResponse
func (a *ApplicationServiceApiService) ApplicationServicePatchResourceExecute(r ApiApplicationServicePatchResourceRequest) (*ApplicationApplicationResourceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApplicationApplicationResourceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServicePatchResource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/resource"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.namespace != nil {
		parameterAddToQuery(localVarQueryParams, "namespace", r.namespace, "")
	}
	if r.resourceName != nil {
		parameterAddToQuery(localVarQueryParams, "resourceName", r.resourceName, "")
	}
	if r.version != nil {
		parameterAddToQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.group != nil {
		parameterAddToQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.kind != nil {
		parameterAddToQuery(localVarQueryParams, "kind", r.kind, "")
	}
	if r.patchType != nil {
		parameterAddToQuery(localVarQueryParams, "patchType", r.patchType, "")
	}
	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServicePodLogsRequest struct {
	ctx              context.Context
	ApiService       *ApplicationServiceApiService
	name             string
	podName          string
	namespace        *string
	container        *string
	sinceSeconds     *string
	sinceTimeSeconds *string
	sinceTimeNanos   *int32
	tailLines        *string
	follow           *bool
	untilTime        *string
	filter           *string
	kind             *string
	group            *string
	resourceName     *string
	previous         *bool
	appNamespace     *string
}

func (r ApiApplicationServicePodLogsRequest) Namespace(namespace string) ApiApplicationServicePodLogsRequest {
	r.namespace = &namespace
	return r
}

func (r ApiApplicationServicePodLogsRequest) Container(container string) ApiApplicationServicePodLogsRequest {
	r.container = &container
	return r
}

func (r ApiApplicationServicePodLogsRequest) SinceSeconds(sinceSeconds string) ApiApplicationServicePodLogsRequest {
	r.sinceSeconds = &sinceSeconds
	return r
}

// Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
func (r ApiApplicationServicePodLogsRequest) SinceTimeSeconds(sinceTimeSeconds string) ApiApplicationServicePodLogsRequest {
	r.sinceTimeSeconds = &sinceTimeSeconds
	return r
}

// Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
func (r ApiApplicationServicePodLogsRequest) SinceTimeNanos(sinceTimeNanos int32) ApiApplicationServicePodLogsRequest {
	r.sinceTimeNanos = &sinceTimeNanos
	return r
}

func (r ApiApplicationServicePodLogsRequest) TailLines(tailLines string) ApiApplicationServicePodLogsRequest {
	r.tailLines = &tailLines
	return r
}

func (r ApiApplicationServicePodLogsRequest) Follow(follow bool) ApiApplicationServicePodLogsRequest {
	r.follow = &follow
	return r
}

func (r ApiApplicationServicePodLogsRequest) UntilTime(untilTime string) ApiApplicationServicePodLogsRequest {
	r.untilTime = &untilTime
	return r
}

func (r ApiApplicationServicePodLogsRequest) Filter(filter string) ApiApplicationServicePodLogsRequest {
	r.filter = &filter
	return r
}

func (r ApiApplicationServicePodLogsRequest) Kind(kind string) ApiApplicationServicePodLogsRequest {
	r.kind = &kind
	return r
}

func (r ApiApplicationServicePodLogsRequest) Group(group string) ApiApplicationServicePodLogsRequest {
	r.group = &group
	return r
}

func (r ApiApplicationServicePodLogsRequest) ResourceName(resourceName string) ApiApplicationServicePodLogsRequest {
	r.resourceName = &resourceName
	return r
}

func (r ApiApplicationServicePodLogsRequest) Previous(previous bool) ApiApplicationServicePodLogsRequest {
	r.previous = &previous
	return r
}

func (r ApiApplicationServicePodLogsRequest) AppNamespace(appNamespace string) ApiApplicationServicePodLogsRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServicePodLogsRequest) Execute() (*StreamResultOfApplicationLogEntry, *http.Response, error) {
	return r.ApiService.ApplicationServicePodLogsExecute(r)
}

/*
ApplicationServicePodLogs PodLogs returns stream of log entries for the specified pod. Pod

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@param podName
	@return ApiApplicationServicePodLogsRequest
*/
func (a *ApplicationServiceApiService) ApplicationServicePodLogs(ctx context.Context, name string, podName string) ApiApplicationServicePodLogsRequest {
	return ApiApplicationServicePodLogsRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
		podName:    podName,
	}
}

// Execute executes the request
//
//	@return StreamResultOfApplicationLogEntry
func (a *ApplicationServiceApiService) ApplicationServicePodLogsExecute(r ApiApplicationServicePodLogsRequest) (*StreamResultOfApplicationLogEntry, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StreamResultOfApplicationLogEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServicePodLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/pods/{podName}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"podName"+"}", url.PathEscape(parameterValueToString(r.podName, "podName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.namespace != nil {
		parameterAddToQuery(localVarQueryParams, "namespace", r.namespace, "")
	}
	if r.container != nil {
		parameterAddToQuery(localVarQueryParams, "container", r.container, "")
	}
	if r.sinceSeconds != nil {
		parameterAddToQuery(localVarQueryParams, "sinceSeconds", r.sinceSeconds, "")
	}
	if r.sinceTimeSeconds != nil {
		parameterAddToQuery(localVarQueryParams, "sinceTime.seconds", r.sinceTimeSeconds, "")
	}
	if r.sinceTimeNanos != nil {
		parameterAddToQuery(localVarQueryParams, "sinceTime.nanos", r.sinceTimeNanos, "")
	}
	if r.tailLines != nil {
		parameterAddToQuery(localVarQueryParams, "tailLines", r.tailLines, "")
	}
	if r.follow != nil {
		parameterAddToQuery(localVarQueryParams, "follow", r.follow, "")
	}
	if r.untilTime != nil {
		parameterAddToQuery(localVarQueryParams, "untilTime", r.untilTime, "")
	}
	if r.filter != nil {
		parameterAddToQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.kind != nil {
		parameterAddToQuery(localVarQueryParams, "kind", r.kind, "")
	}
	if r.group != nil {
		parameterAddToQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.resourceName != nil {
		parameterAddToQuery(localVarQueryParams, "resourceName", r.resourceName, "")
	}
	if r.previous != nil {
		parameterAddToQuery(localVarQueryParams, "previous", r.previous, "")
	}
	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServicePodLogs2Request struct {
	ctx              context.Context
	ApiService       *ApplicationServiceApiService
	name             string
	namespace        *string
	podName          *string
	container        *string
	sinceSeconds     *string
	sinceTimeSeconds *string
	sinceTimeNanos   *int32
	tailLines        *string
	follow           *bool
	untilTime        *string
	filter           *string
	kind             *string
	group            *string
	resourceName     *string
	previous         *bool
	appNamespace     *string
}

func (r ApiApplicationServicePodLogs2Request) Namespace(namespace string) ApiApplicationServicePodLogs2Request {
	r.namespace = &namespace
	return r
}

func (r ApiApplicationServicePodLogs2Request) PodName(podName string) ApiApplicationServicePodLogs2Request {
	r.podName = &podName
	return r
}

func (r ApiApplicationServicePodLogs2Request) Container(container string) ApiApplicationServicePodLogs2Request {
	r.container = &container
	return r
}

func (r ApiApplicationServicePodLogs2Request) SinceSeconds(sinceSeconds string) ApiApplicationServicePodLogs2Request {
	r.sinceSeconds = &sinceSeconds
	return r
}

// Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
func (r ApiApplicationServicePodLogs2Request) SinceTimeSeconds(sinceTimeSeconds string) ApiApplicationServicePodLogs2Request {
	r.sinceTimeSeconds = &sinceTimeSeconds
	return r
}

// Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
func (r ApiApplicationServicePodLogs2Request) SinceTimeNanos(sinceTimeNanos int32) ApiApplicationServicePodLogs2Request {
	r.sinceTimeNanos = &sinceTimeNanos
	return r
}

func (r ApiApplicationServicePodLogs2Request) TailLines(tailLines string) ApiApplicationServicePodLogs2Request {
	r.tailLines = &tailLines
	return r
}

func (r ApiApplicationServicePodLogs2Request) Follow(follow bool) ApiApplicationServicePodLogs2Request {
	r.follow = &follow
	return r
}

func (r ApiApplicationServicePodLogs2Request) UntilTime(untilTime string) ApiApplicationServicePodLogs2Request {
	r.untilTime = &untilTime
	return r
}

func (r ApiApplicationServicePodLogs2Request) Filter(filter string) ApiApplicationServicePodLogs2Request {
	r.filter = &filter
	return r
}

func (r ApiApplicationServicePodLogs2Request) Kind(kind string) ApiApplicationServicePodLogs2Request {
	r.kind = &kind
	return r
}

func (r ApiApplicationServicePodLogs2Request) Group(group string) ApiApplicationServicePodLogs2Request {
	r.group = &group
	return r
}

func (r ApiApplicationServicePodLogs2Request) ResourceName(resourceName string) ApiApplicationServicePodLogs2Request {
	r.resourceName = &resourceName
	return r
}

func (r ApiApplicationServicePodLogs2Request) Previous(previous bool) ApiApplicationServicePodLogs2Request {
	r.previous = &previous
	return r
}

func (r ApiApplicationServicePodLogs2Request) AppNamespace(appNamespace string) ApiApplicationServicePodLogs2Request {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServicePodLogs2Request) Execute() (*StreamResultOfApplicationLogEntry, *http.Response, error) {
	return r.ApiService.ApplicationServicePodLogs2Execute(r)
}

/*
ApplicationServicePodLogs2 PodLogs returns stream of log entries for the specified pod. Pod

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiApplicationServicePodLogs2Request
*/
func (a *ApplicationServiceApiService) ApplicationServicePodLogs2(ctx context.Context, name string) ApiApplicationServicePodLogs2Request {
	return ApiApplicationServicePodLogs2Request{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
//
//	@return StreamResultOfApplicationLogEntry
func (a *ApplicationServiceApiService) ApplicationServicePodLogs2Execute(r ApiApplicationServicePodLogs2Request) (*StreamResultOfApplicationLogEntry, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StreamResultOfApplicationLogEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServicePodLogs2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.namespace != nil {
		parameterAddToQuery(localVarQueryParams, "namespace", r.namespace, "")
	}
	if r.podName != nil {
		parameterAddToQuery(localVarQueryParams, "podName", r.podName, "")
	}
	if r.container != nil {
		parameterAddToQuery(localVarQueryParams, "container", r.container, "")
	}
	if r.sinceSeconds != nil {
		parameterAddToQuery(localVarQueryParams, "sinceSeconds", r.sinceSeconds, "")
	}
	if r.sinceTimeSeconds != nil {
		parameterAddToQuery(localVarQueryParams, "sinceTime.seconds", r.sinceTimeSeconds, "")
	}
	if r.sinceTimeNanos != nil {
		parameterAddToQuery(localVarQueryParams, "sinceTime.nanos", r.sinceTimeNanos, "")
	}
	if r.tailLines != nil {
		parameterAddToQuery(localVarQueryParams, "tailLines", r.tailLines, "")
	}
	if r.follow != nil {
		parameterAddToQuery(localVarQueryParams, "follow", r.follow, "")
	}
	if r.untilTime != nil {
		parameterAddToQuery(localVarQueryParams, "untilTime", r.untilTime, "")
	}
	if r.filter != nil {
		parameterAddToQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.kind != nil {
		parameterAddToQuery(localVarQueryParams, "kind", r.kind, "")
	}
	if r.group != nil {
		parameterAddToQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.resourceName != nil {
		parameterAddToQuery(localVarQueryParams, "resourceName", r.resourceName, "")
	}
	if r.previous != nil {
		parameterAddToQuery(localVarQueryParams, "previous", r.previous, "")
	}
	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceResourceTreeRequest struct {
	ctx             context.Context
	ApiService      *ApplicationServiceApiService
	applicationName string
	namespace       *string
	name            *string
	version         *string
	group           *string
	kind            *string
	appNamespace    *string
}

func (r ApiApplicationServiceResourceTreeRequest) Namespace(namespace string) ApiApplicationServiceResourceTreeRequest {
	r.namespace = &namespace
	return r
}

func (r ApiApplicationServiceResourceTreeRequest) Name(name string) ApiApplicationServiceResourceTreeRequest {
	r.name = &name
	return r
}

func (r ApiApplicationServiceResourceTreeRequest) Version(version string) ApiApplicationServiceResourceTreeRequest {
	r.version = &version
	return r
}

func (r ApiApplicationServiceResourceTreeRequest) Group(group string) ApiApplicationServiceResourceTreeRequest {
	r.group = &group
	return r
}

func (r ApiApplicationServiceResourceTreeRequest) Kind(kind string) ApiApplicationServiceResourceTreeRequest {
	r.kind = &kind
	return r
}

func (r ApiApplicationServiceResourceTreeRequest) AppNamespace(appNamespace string) ApiApplicationServiceResourceTreeRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceResourceTreeRequest) Execute() (*V1alpha1ApplicationTree, *http.Response, error) {
	return r.ApiService.ApplicationServiceResourceTreeExecute(r)
}

/*
ApplicationServiceResourceTree ResourceTree returns resource tree

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationName
	@return ApiApplicationServiceResourceTreeRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceResourceTree(ctx context.Context, applicationName string) ApiApplicationServiceResourceTreeRequest {
	return ApiApplicationServiceResourceTreeRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationName: applicationName,
	}
}

// Execute executes the request
//
//	@return V1alpha1ApplicationTree
func (a *ApplicationServiceApiService) ApplicationServiceResourceTreeExecute(r ApiApplicationServiceResourceTreeRequest) (*V1alpha1ApplicationTree, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V1alpha1ApplicationTree
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceResourceTree")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{applicationName}/resource-tree"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationName"+"}", url.PathEscape(parameterValueToString(r.applicationName, "applicationName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.namespace != nil {
		parameterAddToQuery(localVarQueryParams, "namespace", r.namespace, "")
	}
	if r.name != nil {
		parameterAddToQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.version != nil {
		parameterAddToQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.group != nil {
		parameterAddToQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.kind != nil {
		parameterAddToQuery(localVarQueryParams, "kind", r.kind, "")
	}
	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceRevisionMetadataRequest struct {
	ctx          context.Context
	ApiService   *ApplicationServiceApiService
	name         string
	revision     string
	appNamespace *string
}

// the application&#39;s namespace.
func (r ApiApplicationServiceRevisionMetadataRequest) AppNamespace(appNamespace string) ApiApplicationServiceRevisionMetadataRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceRevisionMetadataRequest) Execute() (*V1alpha1RevisionMetadata, *http.Response, error) {
	return r.ApiService.ApplicationServiceRevisionMetadataExecute(r)
}

/*
ApplicationServiceRevisionMetadata Get the meta-data (author, date, tags, message) for a specific revision of the application

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name the application's name
	@param revision the revision of the app
	@return ApiApplicationServiceRevisionMetadataRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceRevisionMetadata(ctx context.Context, name string, revision string) ApiApplicationServiceRevisionMetadataRequest {
	return ApiApplicationServiceRevisionMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
		revision:   revision,
	}
}

// Execute executes the request
//
//	@return V1alpha1RevisionMetadata
func (a *ApplicationServiceApiService) ApplicationServiceRevisionMetadataExecute(r ApiApplicationServiceRevisionMetadataRequest) (*V1alpha1RevisionMetadata, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V1alpha1RevisionMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceRevisionMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/revisions/{revision}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"revision"+"}", url.PathEscape(parameterValueToString(r.revision, "revision")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceRollbackRequest struct {
	ctx        context.Context
	ApiService *ApplicationServiceApiService
	name       string
	body       *ApplicationApplicationRollbackRequest
}

func (r ApiApplicationServiceRollbackRequest) Body(body ApplicationApplicationRollbackRequest) ApiApplicationServiceRollbackRequest {
	r.body = &body
	return r
}

func (r ApiApplicationServiceRollbackRequest) Execute() (*V1alpha1Application, *http.Response, error) {
	return r.ApiService.ApplicationServiceRollbackExecute(r)
}

/*
ApplicationServiceRollback Rollback syncs an application to its target state

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiApplicationServiceRollbackRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceRollback(ctx context.Context, name string) ApiApplicationServiceRollbackRequest {
	return ApiApplicationServiceRollbackRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
//
//	@return V1alpha1Application
func (a *ApplicationServiceApiService) ApplicationServiceRollbackExecute(r ApiApplicationServiceRollbackRequest) (*V1alpha1Application, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V1alpha1Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceRollback")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/rollback"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceRunResourceActionRequest struct {
	ctx          context.Context
	ApiService   *ApplicationServiceApiService
	name         string
	body         *string
	namespace    *string
	resourceName *string
	version      *string
	group        *string
	kind         *string
	appNamespace *string
}

func (r ApiApplicationServiceRunResourceActionRequest) Body(body string) ApiApplicationServiceRunResourceActionRequest {
	r.body = &body
	return r
}

func (r ApiApplicationServiceRunResourceActionRequest) Namespace(namespace string) ApiApplicationServiceRunResourceActionRequest {
	r.namespace = &namespace
	return r
}

func (r ApiApplicationServiceRunResourceActionRequest) ResourceName(resourceName string) ApiApplicationServiceRunResourceActionRequest {
	r.resourceName = &resourceName
	return r
}

func (r ApiApplicationServiceRunResourceActionRequest) Version(version string) ApiApplicationServiceRunResourceActionRequest {
	r.version = &version
	return r
}

func (r ApiApplicationServiceRunResourceActionRequest) Group(group string) ApiApplicationServiceRunResourceActionRequest {
	r.group = &group
	return r
}

func (r ApiApplicationServiceRunResourceActionRequest) Kind(kind string) ApiApplicationServiceRunResourceActionRequest {
	r.kind = &kind
	return r
}

func (r ApiApplicationServiceRunResourceActionRequest) AppNamespace(appNamespace string) ApiApplicationServiceRunResourceActionRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceRunResourceActionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApplicationServiceRunResourceActionExecute(r)
}

/*
ApplicationServiceRunResourceAction RunResourceAction run resource action

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiApplicationServiceRunResourceActionRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceRunResourceAction(ctx context.Context, name string) ApiApplicationServiceRunResourceActionRequest {
	return ApiApplicationServiceRunResourceActionRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ApplicationServiceApiService) ApplicationServiceRunResourceActionExecute(r ApiApplicationServiceRunResourceActionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceRunResourceAction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/resource/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.namespace != nil {
		parameterAddToQuery(localVarQueryParams, "namespace", r.namespace, "")
	}
	if r.resourceName != nil {
		parameterAddToQuery(localVarQueryParams, "resourceName", r.resourceName, "")
	}
	if r.version != nil {
		parameterAddToQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.group != nil {
		parameterAddToQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.kind != nil {
		parameterAddToQuery(localVarQueryParams, "kind", r.kind, "")
	}
	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceSyncRequest struct {
	ctx        context.Context
	ApiService *ApplicationServiceApiService
	name       string
	body       *ApplicationApplicationSyncRequest
}

func (r ApiApplicationServiceSyncRequest) Body(body ApplicationApplicationSyncRequest) ApiApplicationServiceSyncRequest {
	r.body = &body
	return r
}

func (r ApiApplicationServiceSyncRequest) Execute() (*V1alpha1Application, *http.Response, error) {
	return r.ApiService.ApplicationServiceSyncExecute(r)
}

/*
ApplicationServiceSync Sync syncs an application to its target state

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiApplicationServiceSyncRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceSync(ctx context.Context, name string) ApiApplicationServiceSyncRequest {
	return ApiApplicationServiceSyncRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
//
//	@return V1alpha1Application
func (a *ApplicationServiceApiService) ApplicationServiceSyncExecute(r ApiApplicationServiceSyncRequest) (*V1alpha1Application, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V1alpha1Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceSync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/sync"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceTerminateOperationRequest struct {
	ctx          context.Context
	ApiService   *ApplicationServiceApiService
	name         string
	appNamespace *string
}

func (r ApiApplicationServiceTerminateOperationRequest) AppNamespace(appNamespace string) ApiApplicationServiceTerminateOperationRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceTerminateOperationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApplicationServiceTerminateOperationExecute(r)
}

/*
ApplicationServiceTerminateOperation TerminateOperation terminates the currently running operation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiApplicationServiceTerminateOperationRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceTerminateOperation(ctx context.Context, name string) ApiApplicationServiceTerminateOperationRequest {
	return ApiApplicationServiceTerminateOperationRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ApplicationServiceApiService) ApplicationServiceTerminateOperationExecute(r ApiApplicationServiceTerminateOperationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceTerminateOperation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/operation"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceUpdateRequest struct {
	ctx                     context.Context
	ApiService              *ApplicationServiceApiService
	applicationMetadataName string
	body                    *V1alpha1Application
	validate                *bool
}

func (r ApiApplicationServiceUpdateRequest) Body(body V1alpha1Application) ApiApplicationServiceUpdateRequest {
	r.body = &body
	return r
}

func (r ApiApplicationServiceUpdateRequest) Validate(validate bool) ApiApplicationServiceUpdateRequest {
	r.validate = &validate
	return r
}

func (r ApiApplicationServiceUpdateRequest) Execute() (*V1alpha1Application, *http.Response, error) {
	return r.ApiService.ApplicationServiceUpdateExecute(r)
}

/*
ApplicationServiceUpdate Update updates an application

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationMetadataName Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names +optional
	@return ApiApplicationServiceUpdateRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceUpdate(ctx context.Context, applicationMetadataName string) ApiApplicationServiceUpdateRequest {
	return ApiApplicationServiceUpdateRequest{
		ApiService:              a,
		ctx:                     ctx,
		applicationMetadataName: applicationMetadataName,
	}
}

// Execute executes the request
//
//	@return V1alpha1Application
func (a *ApplicationServiceApiService) ApplicationServiceUpdateExecute(r ApiApplicationServiceUpdateRequest) (*V1alpha1Application, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V1alpha1Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{application.metadata.name}"
	localVarPath = strings.Replace(localVarPath, "{"+"application.metadata.name"+"}", url.PathEscape(parameterValueToString(r.applicationMetadataName, "applicationMetadataName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.validate != nil {
		parameterAddToQuery(localVarQueryParams, "validate", r.validate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceUpdateSpecRequest struct {
	ctx          context.Context
	ApiService   *ApplicationServiceApiService
	name         string
	body         *V1alpha1ApplicationSpec
	validate     *bool
	appNamespace *string
}

func (r ApiApplicationServiceUpdateSpecRequest) Body(body V1alpha1ApplicationSpec) ApiApplicationServiceUpdateSpecRequest {
	r.body = &body
	return r
}

func (r ApiApplicationServiceUpdateSpecRequest) Validate(validate bool) ApiApplicationServiceUpdateSpecRequest {
	r.validate = &validate
	return r
}

func (r ApiApplicationServiceUpdateSpecRequest) AppNamespace(appNamespace string) ApiApplicationServiceUpdateSpecRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceUpdateSpecRequest) Execute() (*V1alpha1ApplicationSpec, *http.Response, error) {
	return r.ApiService.ApplicationServiceUpdateSpecExecute(r)
}

/*
ApplicationServiceUpdateSpec UpdateSpec updates an application spec

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiApplicationServiceUpdateSpecRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceUpdateSpec(ctx context.Context, name string) ApiApplicationServiceUpdateSpecRequest {
	return ApiApplicationServiceUpdateSpecRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
//
//	@return V1alpha1ApplicationSpec
func (a *ApplicationServiceApiService) ApplicationServiceUpdateSpecExecute(r ApiApplicationServiceUpdateSpecRequest) (*V1alpha1ApplicationSpec, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V1alpha1ApplicationSpec
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceUpdateSpec")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/spec"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.validate != nil {
		parameterAddToQuery(localVarQueryParams, "validate", r.validate, "")
	}
	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceWatchRequest struct {
	ctx             context.Context
	ApiService      *ApplicationServiceApiService
	name            *string
	refresh         *string
	projects        *[]string
	resourceVersion *string
	selector        *string
	repo            *string
	appNamespace    *string
}

// the application&#39;s name.
func (r ApiApplicationServiceWatchRequest) Name(name string) ApiApplicationServiceWatchRequest {
	r.name = &name
	return r
}

// forces application reconciliation if set to true.
func (r ApiApplicationServiceWatchRequest) Refresh(refresh string) ApiApplicationServiceWatchRequest {
	r.refresh = &refresh
	return r
}

// the project names to restrict returned list applications.
func (r ApiApplicationServiceWatchRequest) Projects(projects []string) ApiApplicationServiceWatchRequest {
	r.projects = &projects
	return r
}

// when specified with a watch call, shows changes that occur after that particular version of a resource.
func (r ApiApplicationServiceWatchRequest) ResourceVersion(resourceVersion string) ApiApplicationServiceWatchRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// the selector to restrict returned list to applications only with matched labels.
func (r ApiApplicationServiceWatchRequest) Selector(selector string) ApiApplicationServiceWatchRequest {
	r.selector = &selector
	return r
}

// the repoURL to restrict returned list applications.
func (r ApiApplicationServiceWatchRequest) Repo(repo string) ApiApplicationServiceWatchRequest {
	r.repo = &repo
	return r
}

// the application&#39;s namespace.
func (r ApiApplicationServiceWatchRequest) AppNamespace(appNamespace string) ApiApplicationServiceWatchRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceWatchRequest) Execute() (*StreamResultOfV1alpha1ApplicationWatchEvent, *http.Response, error) {
	return r.ApiService.ApplicationServiceWatchExecute(r)
}

/*
ApplicationServiceWatch Watch returns stream of application change events

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApplicationServiceWatchRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceWatch(ctx context.Context) ApiApplicationServiceWatchRequest {
	return ApiApplicationServiceWatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StreamResultOfV1alpha1ApplicationWatchEvent
func (a *ApplicationServiceApiService) ApplicationServiceWatchExecute(r ApiApplicationServiceWatchRequest) (*StreamResultOfV1alpha1ApplicationWatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StreamResultOfV1alpha1ApplicationWatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceWatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/stream/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.refresh != nil {
		parameterAddToQuery(localVarQueryParams, "refresh", r.refresh, "")
	}
	if r.projects != nil {
		t := *r.projects
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToQuery(localVarQueryParams, "projects", s.Index(i), "multi")
			}
		} else {
			parameterAddToQuery(localVarQueryParams, "projects", t, "multi")
		}
	}
	if r.resourceVersion != nil {
		parameterAddToQuery(localVarQueryParams, "resourceVersion", r.resourceVersion, "")
	}
	if r.selector != nil {
		parameterAddToQuery(localVarQueryParams, "selector", r.selector, "")
	}
	if r.repo != nil {
		parameterAddToQuery(localVarQueryParams, "repo", r.repo, "")
	}
	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceWatchResourceTreeRequest struct {
	ctx             context.Context
	ApiService      *ApplicationServiceApiService
	applicationName string
	namespace       *string
	name            *string
	version         *string
	group           *string
	kind            *string
	appNamespace    *string
}

func (r ApiApplicationServiceWatchResourceTreeRequest) Namespace(namespace string) ApiApplicationServiceWatchResourceTreeRequest {
	r.namespace = &namespace
	return r
}

func (r ApiApplicationServiceWatchResourceTreeRequest) Name(name string) ApiApplicationServiceWatchResourceTreeRequest {
	r.name = &name
	return r
}

func (r ApiApplicationServiceWatchResourceTreeRequest) Version(version string) ApiApplicationServiceWatchResourceTreeRequest {
	r.version = &version
	return r
}

func (r ApiApplicationServiceWatchResourceTreeRequest) Group(group string) ApiApplicationServiceWatchResourceTreeRequest {
	r.group = &group
	return r
}

func (r ApiApplicationServiceWatchResourceTreeRequest) Kind(kind string) ApiApplicationServiceWatchResourceTreeRequest {
	r.kind = &kind
	return r
}

func (r ApiApplicationServiceWatchResourceTreeRequest) AppNamespace(appNamespace string) ApiApplicationServiceWatchResourceTreeRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceWatchResourceTreeRequest) Execute() (*StreamResultOfV1alpha1ApplicationTree, *http.Response, error) {
	return r.ApiService.ApplicationServiceWatchResourceTreeExecute(r)
}

/*
ApplicationServiceWatchResourceTree Watch returns stream of application resource tree

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param applicationName
	@return ApiApplicationServiceWatchResourceTreeRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceWatchResourceTree(ctx context.Context, applicationName string) ApiApplicationServiceWatchResourceTreeRequest {
	return ApiApplicationServiceWatchResourceTreeRequest{
		ApiService:      a,
		ctx:             ctx,
		applicationName: applicationName,
	}
}

// Execute executes the request
//
//	@return StreamResultOfV1alpha1ApplicationTree
func (a *ApplicationServiceApiService) ApplicationServiceWatchResourceTreeExecute(r ApiApplicationServiceWatchResourceTreeRequest) (*StreamResultOfV1alpha1ApplicationTree, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StreamResultOfV1alpha1ApplicationTree
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceWatchResourceTree")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/stream/applications/{applicationName}/resource-tree"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationName"+"}", url.PathEscape(parameterValueToString(r.applicationName, "applicationName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.namespace != nil {
		parameterAddToQuery(localVarQueryParams, "namespace", r.namespace, "")
	}
	if r.name != nil {
		parameterAddToQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.version != nil {
		parameterAddToQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.group != nil {
		parameterAddToQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.kind != nil {
		parameterAddToQuery(localVarQueryParams, "kind", r.kind, "")
	}
	if r.appNamespace != nil {
		parameterAddToQuery(localVarQueryParams, "appNamespace", r.appNamespace, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
