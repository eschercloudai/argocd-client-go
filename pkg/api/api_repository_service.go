/*
Consolidate Services

Description of all APIs

API version: version not set
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// RepositoryServiceApiService RepositoryServiceApi service
type RepositoryServiceApiService service

type ApiRepositoryServiceCreateRepositoryRequest struct {
	ctx        context.Context
	ApiService *RepositoryServiceApiService
	body       *V1alpha1Repository
	upsert     *bool
	credsOnly  *bool
}

// Repository definition
func (r ApiRepositoryServiceCreateRepositoryRequest) Body(body V1alpha1Repository) ApiRepositoryServiceCreateRepositoryRequest {
	r.body = &body
	return r
}

// Whether to create in upsert mode.
func (r ApiRepositoryServiceCreateRepositoryRequest) Upsert(upsert bool) ApiRepositoryServiceCreateRepositoryRequest {
	r.upsert = &upsert
	return r
}

// Whether to operate on credential set instead of repository.
func (r ApiRepositoryServiceCreateRepositoryRequest) CredsOnly(credsOnly bool) ApiRepositoryServiceCreateRepositoryRequest {
	r.credsOnly = &credsOnly
	return r
}

func (r ApiRepositoryServiceCreateRepositoryRequest) Execute() (*V1alpha1Repository, *http.Response, error) {
	return r.ApiService.RepositoryServiceCreateRepositoryExecute(r)
}

/*
RepositoryServiceCreateRepository CreateRepository creates a new repository configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRepositoryServiceCreateRepositoryRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceCreateRepository(ctx context.Context) ApiRepositoryServiceCreateRepositoryRequest {
	return ApiRepositoryServiceCreateRepositoryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V1alpha1Repository
func (a *RepositoryServiceApiService) RepositoryServiceCreateRepositoryExecute(r ApiRepositoryServiceCreateRepositoryRequest) (*V1alpha1Repository, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V1alpha1Repository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceCreateRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.upsert != nil {
		parameterAddToQuery(localVarQueryParams, "upsert", r.upsert, "")
	}
	if r.credsOnly != nil {
		parameterAddToQuery(localVarQueryParams, "credsOnly", r.credsOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoryServiceDeleteRepositoryRequest struct {
	ctx          context.Context
	ApiService   *RepositoryServiceApiService
	repo         string
	forceRefresh *bool
}

// Whether to force a cache refresh on repo&#39;s connection state.
func (r ApiRepositoryServiceDeleteRepositoryRequest) ForceRefresh(forceRefresh bool) ApiRepositoryServiceDeleteRepositoryRequest {
	r.forceRefresh = &forceRefresh
	return r
}

func (r ApiRepositoryServiceDeleteRepositoryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RepositoryServiceDeleteRepositoryExecute(r)
}

/*
RepositoryServiceDeleteRepository DeleteRepository deletes a repository from the configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param repo Repo URL for query
	@return ApiRepositoryServiceDeleteRepositoryRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceDeleteRepository(ctx context.Context, repo string) ApiRepositoryServiceDeleteRepositoryRequest {
	return ApiRepositoryServiceDeleteRepositoryRequest{
		ApiService: a,
		ctx:        ctx,
		repo:       repo,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *RepositoryServiceApiService) RepositoryServiceDeleteRepositoryExecute(r ApiRepositoryServiceDeleteRepositoryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceDeleteRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories/{repo}"
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterValueToString(r.repo, "repo")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forceRefresh != nil {
		parameterAddToQuery(localVarQueryParams, "forceRefresh", r.forceRefresh, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoryServiceGetRequest struct {
	ctx          context.Context
	ApiService   *RepositoryServiceApiService
	repo         string
	forceRefresh *bool
}

// Whether to force a cache refresh on repo&#39;s connection state.
func (r ApiRepositoryServiceGetRequest) ForceRefresh(forceRefresh bool) ApiRepositoryServiceGetRequest {
	r.forceRefresh = &forceRefresh
	return r
}

func (r ApiRepositoryServiceGetRequest) Execute() (*V1alpha1Repository, *http.Response, error) {
	return r.ApiService.RepositoryServiceGetExecute(r)
}

/*
RepositoryServiceGet Get returns a repository or its credentials

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param repo Repo URL for query
	@return ApiRepositoryServiceGetRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceGet(ctx context.Context, repo string) ApiRepositoryServiceGetRequest {
	return ApiRepositoryServiceGetRequest{
		ApiService: a,
		ctx:        ctx,
		repo:       repo,
	}
}

// Execute executes the request
//
//	@return V1alpha1Repository
func (a *RepositoryServiceApiService) RepositoryServiceGetExecute(r ApiRepositoryServiceGetRequest) (*V1alpha1Repository, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V1alpha1Repository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories/{repo}"
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterValueToString(r.repo, "repo")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forceRefresh != nil {
		parameterAddToQuery(localVarQueryParams, "forceRefresh", r.forceRefresh, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoryServiceGetAppDetailsRequest struct {
	ctx           context.Context
	ApiService    *RepositoryServiceApiService
	sourceRepoURL string
	body          *RepositoryRepoAppDetailsQuery
}

func (r ApiRepositoryServiceGetAppDetailsRequest) Body(body RepositoryRepoAppDetailsQuery) ApiRepositoryServiceGetAppDetailsRequest {
	r.body = &body
	return r
}

func (r ApiRepositoryServiceGetAppDetailsRequest) Execute() (*RepositoryRepoAppDetailsResponse, *http.Response, error) {
	return r.ApiService.RepositoryServiceGetAppDetailsExecute(r)
}

/*
RepositoryServiceGetAppDetails GetAppDetails returns application details by given path

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sourceRepoURL RepoURL is the URL to the repository (Git or Helm) that contains the application manifests
	@return ApiRepositoryServiceGetAppDetailsRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceGetAppDetails(ctx context.Context, sourceRepoURL string) ApiRepositoryServiceGetAppDetailsRequest {
	return ApiRepositoryServiceGetAppDetailsRequest{
		ApiService:    a,
		ctx:           ctx,
		sourceRepoURL: sourceRepoURL,
	}
}

// Execute executes the request
//
//	@return RepositoryRepoAppDetailsResponse
func (a *RepositoryServiceApiService) RepositoryServiceGetAppDetailsExecute(r ApiRepositoryServiceGetAppDetailsRequest) (*RepositoryRepoAppDetailsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RepositoryRepoAppDetailsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceGetAppDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories/{source.repoURL}/appdetails"
	localVarPath = strings.Replace(localVarPath, "{"+"source.repoURL"+"}", url.PathEscape(parameterValueToString(r.sourceRepoURL, "sourceRepoURL")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoryServiceGetHelmChartsRequest struct {
	ctx          context.Context
	ApiService   *RepositoryServiceApiService
	repo         string
	forceRefresh *bool
}

// Whether to force a cache refresh on repo&#39;s connection state.
func (r ApiRepositoryServiceGetHelmChartsRequest) ForceRefresh(forceRefresh bool) ApiRepositoryServiceGetHelmChartsRequest {
	r.forceRefresh = &forceRefresh
	return r
}

func (r ApiRepositoryServiceGetHelmChartsRequest) Execute() (*RepositoryHelmChartsResponse, *http.Response, error) {
	return r.ApiService.RepositoryServiceGetHelmChartsExecute(r)
}

/*
RepositoryServiceGetHelmCharts GetHelmCharts returns list of helm charts in the specified repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param repo Repo URL for query
	@return ApiRepositoryServiceGetHelmChartsRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceGetHelmCharts(ctx context.Context, repo string) ApiRepositoryServiceGetHelmChartsRequest {
	return ApiRepositoryServiceGetHelmChartsRequest{
		ApiService: a,
		ctx:        ctx,
		repo:       repo,
	}
}

// Execute executes the request
//
//	@return RepositoryHelmChartsResponse
func (a *RepositoryServiceApiService) RepositoryServiceGetHelmChartsExecute(r ApiRepositoryServiceGetHelmChartsRequest) (*RepositoryHelmChartsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RepositoryHelmChartsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceGetHelmCharts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories/{repo}/helmcharts"
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterValueToString(r.repo, "repo")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forceRefresh != nil {
		parameterAddToQuery(localVarQueryParams, "forceRefresh", r.forceRefresh, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoryServiceListAppsRequest struct {
	ctx        context.Context
	ApiService *RepositoryServiceApiService
	repo       string
	revision   *string
	appName    *string
	appProject *string
}

func (r ApiRepositoryServiceListAppsRequest) Revision(revision string) ApiRepositoryServiceListAppsRequest {
	r.revision = &revision
	return r
}

func (r ApiRepositoryServiceListAppsRequest) AppName(appName string) ApiRepositoryServiceListAppsRequest {
	r.appName = &appName
	return r
}

func (r ApiRepositoryServiceListAppsRequest) AppProject(appProject string) ApiRepositoryServiceListAppsRequest {
	r.appProject = &appProject
	return r
}

func (r ApiRepositoryServiceListAppsRequest) Execute() (*RepositoryRepoAppsResponse, *http.Response, error) {
	return r.ApiService.RepositoryServiceListAppsExecute(r)
}

/*
RepositoryServiceListApps ListApps returns list of apps in the repo

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param repo
	@return ApiRepositoryServiceListAppsRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceListApps(ctx context.Context, repo string) ApiRepositoryServiceListAppsRequest {
	return ApiRepositoryServiceListAppsRequest{
		ApiService: a,
		ctx:        ctx,
		repo:       repo,
	}
}

// Execute executes the request
//
//	@return RepositoryRepoAppsResponse
func (a *RepositoryServiceApiService) RepositoryServiceListAppsExecute(r ApiRepositoryServiceListAppsRequest) (*RepositoryRepoAppsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RepositoryRepoAppsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceListApps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories/{repo}/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterValueToString(r.repo, "repo")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.revision != nil {
		parameterAddToQuery(localVarQueryParams, "revision", r.revision, "")
	}
	if r.appName != nil {
		parameterAddToQuery(localVarQueryParams, "appName", r.appName, "")
	}
	if r.appProject != nil {
		parameterAddToQuery(localVarQueryParams, "appProject", r.appProject, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoryServiceListRefsRequest struct {
	ctx          context.Context
	ApiService   *RepositoryServiceApiService
	repo         string
	forceRefresh *bool
}

// Whether to force a cache refresh on repo&#39;s connection state.
func (r ApiRepositoryServiceListRefsRequest) ForceRefresh(forceRefresh bool) ApiRepositoryServiceListRefsRequest {
	r.forceRefresh = &forceRefresh
	return r
}

func (r ApiRepositoryServiceListRefsRequest) Execute() (*RepositoryRefs, *http.Response, error) {
	return r.ApiService.RepositoryServiceListRefsExecute(r)
}

/*
RepositoryServiceListRefs Method for RepositoryServiceListRefs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param repo Repo URL for query
	@return ApiRepositoryServiceListRefsRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceListRefs(ctx context.Context, repo string) ApiRepositoryServiceListRefsRequest {
	return ApiRepositoryServiceListRefsRequest{
		ApiService: a,
		ctx:        ctx,
		repo:       repo,
	}
}

// Execute executes the request
//
//	@return RepositoryRefs
func (a *RepositoryServiceApiService) RepositoryServiceListRefsExecute(r ApiRepositoryServiceListRefsRequest) (*RepositoryRefs, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RepositoryRefs
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceListRefs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories/{repo}/refs"
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterValueToString(r.repo, "repo")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forceRefresh != nil {
		parameterAddToQuery(localVarQueryParams, "forceRefresh", r.forceRefresh, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoryServiceListRepositoriesRequest struct {
	ctx          context.Context
	ApiService   *RepositoryServiceApiService
	repo         *string
	forceRefresh *bool
}

// Repo URL for query.
func (r ApiRepositoryServiceListRepositoriesRequest) Repo(repo string) ApiRepositoryServiceListRepositoriesRequest {
	r.repo = &repo
	return r
}

// Whether to force a cache refresh on repo&#39;s connection state.
func (r ApiRepositoryServiceListRepositoriesRequest) ForceRefresh(forceRefresh bool) ApiRepositoryServiceListRepositoriesRequest {
	r.forceRefresh = &forceRefresh
	return r
}

func (r ApiRepositoryServiceListRepositoriesRequest) Execute() (*V1alpha1RepositoryList, *http.Response, error) {
	return r.ApiService.RepositoryServiceListRepositoriesExecute(r)
}

/*
RepositoryServiceListRepositories ListRepositories gets a list of all configured repositories

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRepositoryServiceListRepositoriesRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceListRepositories(ctx context.Context) ApiRepositoryServiceListRepositoriesRequest {
	return ApiRepositoryServiceListRepositoriesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V1alpha1RepositoryList
func (a *RepositoryServiceApiService) RepositoryServiceListRepositoriesExecute(r ApiRepositoryServiceListRepositoriesRequest) (*V1alpha1RepositoryList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V1alpha1RepositoryList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceListRepositories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.repo != nil {
		parameterAddToQuery(localVarQueryParams, "repo", r.repo, "")
	}
	if r.forceRefresh != nil {
		parameterAddToQuery(localVarQueryParams, "forceRefresh", r.forceRefresh, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoryServiceUpdateRepositoryRequest struct {
	ctx        context.Context
	ApiService *RepositoryServiceApiService
	repoRepo   string
	body       *V1alpha1Repository
}

func (r ApiRepositoryServiceUpdateRepositoryRequest) Body(body V1alpha1Repository) ApiRepositoryServiceUpdateRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiRepositoryServiceUpdateRepositoryRequest) Execute() (*V1alpha1Repository, *http.Response, error) {
	return r.ApiService.RepositoryServiceUpdateRepositoryExecute(r)
}

/*
RepositoryServiceUpdateRepository UpdateRepository updates a repository configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param repoRepo Repo contains the URL to the remote repository
	@return ApiRepositoryServiceUpdateRepositoryRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceUpdateRepository(ctx context.Context, repoRepo string) ApiRepositoryServiceUpdateRepositoryRequest {
	return ApiRepositoryServiceUpdateRepositoryRequest{
		ApiService: a,
		ctx:        ctx,
		repoRepo:   repoRepo,
	}
}

// Execute executes the request
//
//	@return V1alpha1Repository
func (a *RepositoryServiceApiService) RepositoryServiceUpdateRepositoryExecute(r ApiRepositoryServiceUpdateRepositoryRequest) (*V1alpha1Repository, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V1alpha1Repository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceUpdateRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories/{repo.repo}"
	localVarPath = strings.Replace(localVarPath, "{"+"repo.repo"+"}", url.PathEscape(parameterValueToString(r.repoRepo, "repoRepo")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoryServiceValidateAccessRequest struct {
	ctx                        context.Context
	ApiService                 *RepositoryServiceApiService
	repo                       string
	body                       *string
	username                   *string
	password                   *string
	sshPrivateKey              *string
	insecure                   *bool
	tlsClientCertData          *string
	tlsClientCertKey           *string
	type_                      *string
	name                       *string
	enableOci                  *bool
	githubAppPrivateKey        *string
	githubAppID                *string
	githubAppInstallationID    *string
	githubAppEnterpriseBaseUrl *string
	proxy                      *string
	project                    *string
}

// The URL to the repo
func (r ApiRepositoryServiceValidateAccessRequest) Body(body string) ApiRepositoryServiceValidateAccessRequest {
	r.body = &body
	return r
}

// Username for accessing repo.
func (r ApiRepositoryServiceValidateAccessRequest) Username(username string) ApiRepositoryServiceValidateAccessRequest {
	r.username = &username
	return r
}

// Password for accessing repo.
func (r ApiRepositoryServiceValidateAccessRequest) Password(password string) ApiRepositoryServiceValidateAccessRequest {
	r.password = &password
	return r
}

// Private key data for accessing SSH repository.
func (r ApiRepositoryServiceValidateAccessRequest) SshPrivateKey(sshPrivateKey string) ApiRepositoryServiceValidateAccessRequest {
	r.sshPrivateKey = &sshPrivateKey
	return r
}

// Whether to skip certificate or host key validation.
func (r ApiRepositoryServiceValidateAccessRequest) Insecure(insecure bool) ApiRepositoryServiceValidateAccessRequest {
	r.insecure = &insecure
	return r
}

// TLS client cert data for accessing HTTPS repository.
func (r ApiRepositoryServiceValidateAccessRequest) TlsClientCertData(tlsClientCertData string) ApiRepositoryServiceValidateAccessRequest {
	r.tlsClientCertData = &tlsClientCertData
	return r
}

// TLS client cert key for accessing HTTPS repository.
func (r ApiRepositoryServiceValidateAccessRequest) TlsClientCertKey(tlsClientCertKey string) ApiRepositoryServiceValidateAccessRequest {
	r.tlsClientCertKey = &tlsClientCertKey
	return r
}

// The type of the repo.
func (r ApiRepositoryServiceValidateAccessRequest) Type_(type_ string) ApiRepositoryServiceValidateAccessRequest {
	r.type_ = &type_
	return r
}

// The name of the repo.
func (r ApiRepositoryServiceValidateAccessRequest) Name(name string) ApiRepositoryServiceValidateAccessRequest {
	r.name = &name
	return r
}

// Whether helm-oci support should be enabled for this repo.
func (r ApiRepositoryServiceValidateAccessRequest) EnableOci(enableOci bool) ApiRepositoryServiceValidateAccessRequest {
	r.enableOci = &enableOci
	return r
}

// Github App Private Key PEM data.
func (r ApiRepositoryServiceValidateAccessRequest) GithubAppPrivateKey(githubAppPrivateKey string) ApiRepositoryServiceValidateAccessRequest {
	r.githubAppPrivateKey = &githubAppPrivateKey
	return r
}

// Github App ID of the app used to access the repo.
func (r ApiRepositoryServiceValidateAccessRequest) GithubAppID(githubAppID string) ApiRepositoryServiceValidateAccessRequest {
	r.githubAppID = &githubAppID
	return r
}

// Github App Installation ID of the installed GitHub App.
func (r ApiRepositoryServiceValidateAccessRequest) GithubAppInstallationID(githubAppInstallationID string) ApiRepositoryServiceValidateAccessRequest {
	r.githubAppInstallationID = &githubAppInstallationID
	return r
}

// Github App Enterprise base url if empty will default to https://api.github.com.
func (r ApiRepositoryServiceValidateAccessRequest) GithubAppEnterpriseBaseUrl(githubAppEnterpriseBaseUrl string) ApiRepositoryServiceValidateAccessRequest {
	r.githubAppEnterpriseBaseUrl = &githubAppEnterpriseBaseUrl
	return r
}

// HTTP/HTTPS proxy to access the repository.
func (r ApiRepositoryServiceValidateAccessRequest) Proxy(proxy string) ApiRepositoryServiceValidateAccessRequest {
	r.proxy = &proxy
	return r
}

// Reference between project and repository that allow you automatically to be added as item inside SourceRepos project entity.
func (r ApiRepositoryServiceValidateAccessRequest) Project(project string) ApiRepositoryServiceValidateAccessRequest {
	r.project = &project
	return r
}

func (r ApiRepositoryServiceValidateAccessRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RepositoryServiceValidateAccessExecute(r)
}

/*
RepositoryServiceValidateAccess ValidateAccess validates access to a repository with given parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param repo The URL to the repo
	@return ApiRepositoryServiceValidateAccessRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceValidateAccess(ctx context.Context, repo string) ApiRepositoryServiceValidateAccessRequest {
	return ApiRepositoryServiceValidateAccessRequest{
		ApiService: a,
		ctx:        ctx,
		repo:       repo,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *RepositoryServiceApiService) RepositoryServiceValidateAccessExecute(r ApiRepositoryServiceValidateAccessRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceValidateAccess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories/{repo}/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterValueToString(r.repo, "repo")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.username != nil {
		parameterAddToQuery(localVarQueryParams, "username", r.username, "")
	}
	if r.password != nil {
		parameterAddToQuery(localVarQueryParams, "password", r.password, "")
	}
	if r.sshPrivateKey != nil {
		parameterAddToQuery(localVarQueryParams, "sshPrivateKey", r.sshPrivateKey, "")
	}
	if r.insecure != nil {
		parameterAddToQuery(localVarQueryParams, "insecure", r.insecure, "")
	}
	if r.tlsClientCertData != nil {
		parameterAddToQuery(localVarQueryParams, "tlsClientCertData", r.tlsClientCertData, "")
	}
	if r.tlsClientCertKey != nil {
		parameterAddToQuery(localVarQueryParams, "tlsClientCertKey", r.tlsClientCertKey, "")
	}
	if r.type_ != nil {
		parameterAddToQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.name != nil {
		parameterAddToQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.enableOci != nil {
		parameterAddToQuery(localVarQueryParams, "enableOci", r.enableOci, "")
	}
	if r.githubAppPrivateKey != nil {
		parameterAddToQuery(localVarQueryParams, "githubAppPrivateKey", r.githubAppPrivateKey, "")
	}
	if r.githubAppID != nil {
		parameterAddToQuery(localVarQueryParams, "githubAppID", r.githubAppID, "")
	}
	if r.githubAppInstallationID != nil {
		parameterAddToQuery(localVarQueryParams, "githubAppInstallationID", r.githubAppInstallationID, "")
	}
	if r.githubAppEnterpriseBaseUrl != nil {
		parameterAddToQuery(localVarQueryParams, "githubAppEnterpriseBaseUrl", r.githubAppEnterpriseBaseUrl, "")
	}
	if r.proxy != nil {
		parameterAddToQuery(localVarQueryParams, "proxy", r.proxy, "")
	}
	if r.project != nil {
		parameterAddToQuery(localVarQueryParams, "project", r.project, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RuntimeError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
